# Design Details (robocompdsl)

This post contains the new design that is adopted in the code generated by the `robocompdsl` for
ROS1/ROS2 middleware. With the new design we dedicate a whole class for ROS middlware. This is class
is declared and defined in the `genericworker.h` header file, which is then isntantiated in
`GenericWorker` class.

```
[
-- class name is choosen from the interface name
class Publisher/Subscriber/Server/Client{InterfaceName} {
]
public:
[   -- publishers are choosen on the basis of different types of data types
       present in the modules containing the interface, the dictionary data
       type is avoided as it is not available in ROS
    -- besides this topic interfaces according to ICE syntax are also declared
       as publishers
    // rclcpp::Publisher<{ComponentName}::msg::{MessageName}>::SharedPtr pub_{PublisherName};
]
[
    -- same heuristic as publishers are employed in subscribers too
    // rclcpp::Subscription<{ComponentName}::msg::{MessageName}>::SharedPtr sub_{SubscriberName};
]
[
    -- servers are declared by checking if the interface
       is not a topic interface and then take all the methods
       as services (is the method doesn't contain the dictionary
       data type), names are decided by the names of methods
    // rclcpp::Service<{ComponentName}::srv::{ServiceName}>::SharedPtr server_{ServerName};
]
[
    -- same heuristic is adopted as servers
    // rclcpp::Client<{ComponentName}::srv::{ServiceName}>::SharedPtr client_{ClientName};
]
[
    -- TO BE ADDED LATER --
    -- to store the data from the Subscriber callback
    // {ComponentName}::msg::{MessageName} {DataType}_msg;
]

    rclcpp::Node::SharedPtr node;

    Publisher/Subscriber/Server/Client{InterfaceName} () {
        node = rclcpp::Node::make_shared ("Node Name");
        // pub_{PublisherName} =
                node->create_publisher<{ComponentName}::msg::{MessageName}>("{TopicName}", 10);
        // sub_{SubscriberName} =
                node->create_subscription<{ComponentName}::msg::{MessageName}>("{TopicName}", 10,
                              std::bind(&Subscriber{InterfaceName}::cb_{SubscriberName}, this, _1));
        // server_{ServerName} =
                node->create_service<{ComponentName}::srv::{ServiceName}>("{TopicName}",
                                    std::bind(&Server{InterfaceName}::{ServerName}, this, _1, _2));
        // client_{ClientName} =
                            node->create_client<{ComponentName}::srv::{ServiceName}>("{TopicName}");
    }
    ~Publisher/Subscriber/Server/Client{InterfaceName} () {}

    // void {ServerName} (const std::shared_ptr<{ComponentName}::srv::{ServiceName}::Request> req,
                          std::shared_ptr<{ComponentName}::srv::{ServiceName}::Response> res) {}
    // void cb_{SubscriberName} (const {ComponentName}::msg::{MessageName}::SharedPtr msg) {}
};
```
